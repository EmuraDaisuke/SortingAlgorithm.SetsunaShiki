# 刹那式
刹那式（せつなしき）は、比較安定ソートアルゴリズムの新手法です。  
ソート済み配列に対し、値の変更を行った箇所に焦点を当て、超高速にソートします。    

以下の特徴があります。  
* 比較ソート
* 安定ソート
* 外部領域：無し
* 平均時間：O(log N)
* 最悪時間：O(log N)
* 最良時間：O(2)
* 再帰：無し

<br>

# 基本となるアルゴリズム
* ソート済み配列に対して、任意の位置の値を変更します。
* （変更位置の値 ＜ 変更位置の下の値）であれば、下方を二分探索し、変更位置から探索位置までを回転します。
* （変更位置の上の値 ＜ 変更位置の値）であれば、上方を二分探索し、変更位置から探索位置までを回転します。

## 具体的な流れ
~~~
ソート済み配列に対して、任意の位置の値を変更します
0 1 2 4 5 6 7 9|ソート済み配列
        ↓
0 1 2 4 x 6 7 9|任意の位置の値を変更
~~~
~~~
（変更位置の値 ＜ 変更位置の下の値）であれば、下方を二分探索し、変更位置から探索位置までを回転します
0 1 2 4 5 3 7 9|[5]=3の場合
0 1 2 4 5|. . .|下方を二分探索
. . .|3 4 5|. .|変更位置から探索位置までを回転
0 1 2 3 4 5 7 9|ソート結果
~~~
~~~
（変更位置の上の値 ＜ 変更位置の値）であれば、上方を二分探索し、変更位置から探索位置までを回転します
0 1 8 4 5 6 7 9|[2]=8の場合
. . .|4 5 6 7 9|上方を二分探索
. .|4 5 6 7 8|.|変更位置から探索位置までを回転
0 1 4 5 6 7 8 9|ソート結果
~~~

<br>

# 工夫した点
同じ値が連続している領域に対して二分探索を行った場合でも、安定性を保てるようにしました。  
* 下方の二分探索では、連続した領域の末尾を探索します。
* 上方の二分探索では、連続した領域の先頭を探索します。

<br>

# ビルド＆テスト
環境は以下のとおりです。
* Windows 10 Pro 64bit
* Core i7-8700 3.20GHz

## **Msvc**
Microsoft(R) C/C++ Optimizing Compiler Version 19.15.26732.1 for x64  
Microsoft (R) Incremental Linker Version 14.15.26732.1  
~~~
cl Main.cpp -Ox -EHsc -Fe:TestMsvc.exe
TestMsvc.exe
~~~

## **clang++**
clang version 7.0.0 (tags/RELEASE_700/final)  
Target: x86_64-w64-windows-gnu  
~~~
clang++ Main.cpp -O3 -o TestClang++.exe
TestClang++.exe
~~~

## **g++**
gcc version 8.2.0 (Rev3, Built by MSYS2 project)  
Target: x86_64-w64-mingw32  
~~~
g++ Main.cpp -O3 -o TestG++.exe
TestG++.exe
~~~
<br>

# 平均ベンチマーク
以下は、ソート済み配列に対し、ランダムな位置を、ランダムな値に変更した場合です。  
単位は秒で、数値が低いほど高速です。  

## **Msvc**
|件数|std::sort|std::stable_sort|刹那式|
|---:|---:|---:|---:|
|10,000|0.00006410|0.00004770|**0.00000190**|
|1,000,000|0.00916610|0.00753640|**0.00029180**|
|100,000,000|0.23774790|1.30206660|**0.01747180**|

## **clang++**
|件数|std::sort|std::stable_sort|刹那式|
|---:|---:|---:|---:|
|10,000|0.00005290|0.00006160|**0.00000020**|
|1,000,000|0.00754440|0.01009760|**0.00003920**|
|100,000,000|1.02647040|1.43888810|**0.01039800**|

## **g++**
|件数|std::sort|std::stable_sort|刹那式|
|---:|---:|---:|---:|
|10,000|0.00008570|0.00008380|**0.00000020**|
|1,000,000|0.01185260|0.00942110|**0.00003780**|
|100,000,000|1.36576920|1.38283890|**0.01030640**|

<br>

# 特性ベンチマーク
以下は全て、「100,000,000」件でソートしました。  
単位は秒で、数値が低いほど高速です。  

## 最悪ケース１
ソート済み配列に対し、先頭を最大値に変更した場合です。  

||std::sort|std::stable_sort|刹那式|
|---:|---:|---:|---:|
|Msvc|0.24552310|1.31975820|**0.03363140**|
|clang++|0.98457310|1.59001550|**0.02440560**|
|g++|1.30654070|1.41271570|**0.02451180**|

## 最悪ケース２
ソート済み配列に対し、末尾を最小値に変更した場合です。  

||std::sort|std::stable_sort|刹那式|
|---:|---:|---:|---:|
|Msvc|0.25440420|1.30800500|**0.03833860**|
|clang++|6.58926600|1.55079530|**0.02815680**|
|g++|6.81361270|1.38467000|**0.02570930**|

## 最良ケース
ソート済み配列に対し、値を変更せずに、位置をランダムにした場合です。  

||std::sort|std::stable_sort|刹那式|
|---:|---:|---:|---:|
|Msvc|0.22714320|1.28550500|**0.00000020**|
|clang++|1.03461340|1.54787000|**0.00000030**|
|g++|1.36841120|1.37394720|**0.00000050**|


<br>

# 余談
如何だったでしょうか？  

ソートは、常に全体で行う必要はないという観点から、差分ソートという考えに至ったアイデアです。  
本来であれば、全体ソートである std::sort と std::stable_sort との比較はフェアではないのですが、差分ソートの有用性を判断していただくには必要かと思い、ベンチマークを掲載することにしました。  
参考になれば幸いです。  

上手く運用すれば、激速なパフォーマンスが得られますが、使い方を誤ると激遅になる諸刃の剣。  

ソートアルゴリズムには、まだ浪漫が残っています。  

---
[颯式（はやてしき）](https://github.com/EmuraDaisuke/SortingAlgorithm.HayateShiki)も併せて読んでいただけると、より楽しめるかも知れません。  
